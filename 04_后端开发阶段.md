# 「初见」APP 后端开发阶段任务文档

## 阶段概述

**时间周期**：第3-4月  
**主要目标**：完成后端服务开发、API接口实现、数据库部署和第三方服务集成  
**交付成果**：完整的后端服务、API文档、数据库、部署环境  
**技术栈**：Node.js + Express + TypeScript + MongoDB + Redis

## 核心任务清单

### 1. 基础服务搭建

#### 1.1 项目初始化
- [ ] **项目脚手架搭建**
  ```bash
  # 创建项目目录结构
  first-moments-backend/
  ├── src/
  │   ├── controllers/     # 控制器层
  │   ├── services/        # 业务逻辑层
  │   ├── models/          # 数据模型层
  │   ├── routes/          # 路由层
  │   ├── middleware/      # 中间件
  │   ├── utils/           # 工具函数
  │   ├── config/          # 配置文件
  │   └── types/           # TypeScript类型定义
  ├── tests/               # 测试文件
  ├── docs/                # API文档
  ├── scripts/             # 脚本文件
  └── docker/              # Docker配置
  ```

- [ ] **依赖包安装和配置**
  ```json
  {
    "dependencies": {
      "express": "^4.18.0",
      "mongoose": "^7.0.0",
      "redis": "^4.6.0",
      "jsonwebtoken": "^9.0.0",
      "bcryptjs": "^2.4.3",
      "multer": "^1.4.5",
      "joi": "^17.9.0",
      "cors": "^2.8.5",
      "helmet": "^7.0.0",
      "compression": "^1.7.4",
      "winston": "^3.8.0",
      "bull": "^4.10.0",
      "socket.io": "^4.7.0"
    },
    "devDependencies": {
      "@types/node": "^20.0.0",
      "@types/express": "^4.17.0",
      "typescript": "^5.0.0",
      "ts-node": "^10.9.0",
      "nodemon": "^3.0.0",
      "jest": "^29.5.0",
      "supertest": "^6.3.0"
    }
  }
  ```

- [ ] **TypeScript配置**
  ```json
  // tsconfig.json
  {
    "compilerOptions": {
      "target": "ES2020",
      "module": "commonjs",
      "lib": ["ES2020"],
      "outDir": "./dist",
      "rootDir": "./src",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "resolveJsonModule": true,
      "declaration": true,
      "declarationMap": true,
      "sourceMap": true
    }
  }
  ```

#### 1.2 基础中间件配置
- [ ] **安全中间件**
  ```typescript
  // 安全头设置
  app.use(helmet());
  
  // CORS配置
  app.use(cors({
    origin: process.env.ALLOWED_ORIGINS?.split(','),
    credentials: true
  }));
  
  // 请求体解析
  app.use(express.json({ limit: '10mb' }));
  app.use(express.urlencoded({ extended: true, limit: '10mb' }));
  
  // 压缩响应
  app.use(compression());
  ```

- [ ] **日志中间件**
  ```typescript
  // Winston日志配置
  const logger = winston.createLogger({
    level: 'info',
    format: winston.format.combine(
      winston.format.timestamp(),
      winston.format.errors({ stack: true }),
      winston.format.json()
    ),
    transports: [
      new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
      new winston.transports.File({ filename: 'logs/combined.log' })
    ]
  });
  ```

- [ ] **错误处理中间件**
  ```typescript
  // 全局错误处理
  app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
    logger.error(err.stack);
    res.status(500).json({
      success: false,
      message: '服务器内部错误',
      error: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  });
  ```

### 2. 数据库设计与实现

#### 2.1 MongoDB数据模型实现
- [ ] **用户模型 (User)**
  ```typescript
  // src/models/User.ts
  import mongoose, { Schema, Document } from 'mongoose';
  import bcrypt from 'bcryptjs';
  
  export interface IUser extends Document {
    username: string;
    email: string;
    phone?: string;
    password: string;
    avatar?: string;
    isEmailVerified: boolean;
    isPhoneVerified: boolean;
    lastLoginAt?: Date;
    createdAt: Date;
    updatedAt: Date;
    comparePassword(candidatePassword: string): Promise<boolean>;
  }
  
  const UserSchema = new Schema<IUser>({
    username: { type: String, required: true, unique: true, trim: true },
    email: { type: String, required: true, unique: true, lowercase: true },
    phone: { type: String, sparse: true },
    password: { type: String, required: true, minlength: 6 },
    avatar: { type: String },
    isEmailVerified: { type: Boolean, default: false },
    isPhoneVerified: { type: Boolean, default: false },
    lastLoginAt: { type: Date }
  }, {
    timestamps: true
  });
  
  // 密码加密中间件
  UserSchema.pre('save', async function(next) {
    if (!this.isModified('password')) return next();
    this.password = await bcrypt.hash(this.password, 12);
    next();
  });
  
  // 密码比较方法
  UserSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
    return bcrypt.compare(candidatePassword, this.password);
  };
  ```

- [ ] **档案模型 (Profile)**
  ```typescript
  // src/models/Profile.ts
  export interface IProfile extends Document {
    userId: mongoose.Types.ObjectId;
    name: string;
    type: 'self' | 'child' | 'spouse' | 'parent' | 'student' | 'friend';
    avatar?: string;
    birthDate?: Date;
    gender?: 'male' | 'female' | 'other';
    bio?: string;
    permissions: IPermission[];
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
  }
  
  interface IPermission {
    userId: mongoose.Types.ObjectId;
    role: 'owner' | 'editor' | 'viewer';
    canEdit: boolean;
    canView: boolean;
    canShare: boolean;
    canDelete: boolean;
    grantedAt: Date;
    grantedBy: mongoose.Types.ObjectId;
  }
  
  const PermissionSchema = new Schema<IPermission>({
    userId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
    role: { type: String, enum: ['owner', 'editor', 'viewer'], required: true },
    canEdit: { type: Boolean, default: false },
    canView: { type: Boolean, default: true },
    canShare: { type: Boolean, default: false },
    canDelete: { type: Boolean, default: false },
    grantedAt: { type: Date, default: Date.now },
    grantedBy: { type: Schema.Types.ObjectId, ref: 'User', required: true }
  });
  
  const ProfileSchema = new Schema<IProfile>({
    userId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
    name: { type: String, required: true, trim: true },
    type: { type: String, enum: ['self', 'child', 'spouse', 'parent', 'student', 'friend'], required: true },
    avatar: { type: String },
    birthDate: { type: Date },
    gender: { type: String, enum: ['male', 'female', 'other'] },
    bio: { type: String, maxlength: 500 },
    permissions: [PermissionSchema],
    isActive: { type: Boolean, default: true }
  }, {
    timestamps: true
  });
  ```

- [ ] **成就模型 (Achievement & UserAchievement)**
  ```typescript
  // src/models/Achievement.ts
  export interface IAchievement extends Document {
    category: string;
    ageGroup: string;
    title: string;
    description: string;
    icon: string;
    difficulty: number;
    tags: string[];
    isDefault: boolean;
    isActive: boolean;
    createdAt: Date;
  }
  
  // src/models/UserAchievement.ts
  export interface IUserAchievement extends Document {
    profileId: mongoose.Types.ObjectId;
    achievementId: mongoose.Types.ObjectId;
    title: string;
    description?: string;
    images: string[];
    videos: string[];
    audio?: string;
    location?: ILocation;
    emotion?: string;
    tags: string[];
    isPublic: boolean;
    recordedBy: mongoose.Types.ObjectId;
    recordedAt: Date;
    achievedAt: Date;
    createdAt: Date;
    updatedAt: Date;
  }
  
  interface ILocation {
    latitude: number;
    longitude: number;
    address: string;
    city: string;
    province: string;
    country: string;
  }
  ```

- [ ] **地图打卡模型 (MapCheckin)**
  ```typescript
  // src/models/MapCheckin.ts
  export interface IMapCheckin extends Document {
    profileId: mongoose.Types.ObjectId;
    type: 'country' | 'province' | 'city' | 'landmark';
    name: string;
    code?: string;
    coordinates: {
      latitude: number;
      longitude: number;
    };
    address: string;
    images: string[];
    description?: string;
    checkedAt: Date;
    createdAt: Date;
  }
  
  const MapCheckinSchema = new Schema<IMapCheckin>({
    profileId: { type: Schema.Types.ObjectId, ref: 'Profile', required: true },
    type: { type: String, enum: ['country', 'province', 'city', 'landmark'], required: true },
    name: { type: String, required: true },
    code: { type: String }, // 地区代码
    coordinates: {
      latitude: { type: Number, required: true },
      longitude: { type: Number, required: true }
    },
    address: { type: String, required: true },
    images: [{ type: String }],
    description: { type: String, maxlength: 1000 },
    checkedAt: { type: Date, required: true }
  }, {
    timestamps: true
  });
  
  // 地理空间索引
  MapCheckinSchema.index({ coordinates: '2dsphere' });
  ```

#### 2.2 Redis缓存实现
- [ ] **Redis连接配置**
  ```typescript
  // src/config/redis.ts
  import Redis from 'redis';
  
  const redisClient = Redis.createClient({
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379'),
    password: process.env.REDIS_PASSWORD,
    db: parseInt(process.env.REDIS_DB || '0')
  });
  
  redisClient.on('error', (err) => {
    console.error('Redis连接错误:', err);
  });
  
  redisClient.on('connect', () => {
    console.log('Redis连接成功');
  });
  ```

- [ ] **缓存服务封装**
  ```typescript
  // src/services/CacheService.ts
  export class CacheService {
    private redis: Redis.RedisClientType;
  
    constructor(redisClient: Redis.RedisClientType) {
      this.redis = redisClient;
    }
  
    async get(key: string): Promise<string | null> {
      return await this.redis.get(key);
    }
  
    async set(key: string, value: string, ttl?: number): Promise<void> {
      if (ttl) {
        await this.redis.setEx(key, ttl, value);
      } else {
        await this.redis.set(key, value);
      }
    }
  
    async del(key: string): Promise<void> {
      await this.redis.del(key);
    }
  
    async exists(key: string): Promise<boolean> {
      return (await this.redis.exists(key)) === 1;
    }
  
    // 缓存用户会话
    async setUserSession(userId: string, sessionData: any, ttl: number = 604800): Promise<void> {
      const key = `user:session:${userId}`;
      await this.set(key, JSON.stringify(sessionData), ttl);
    }
  
    // 缓存热门成就
    async setHotAchievements(category: string, achievements: any[], ttl: number = 3600): Promise<void> {
      const key = `achievement:hot:${category}`;
      await this.set(key, JSON.stringify(achievements), ttl);
    }
  }
  ```

### 3. 认证授权系统

#### 3.1 JWT认证实现
- [ ] **JWT工具类**
  ```typescript
  // src/utils/jwt.ts
  import jwt from 'jsonwebtoken';
  
  export interface JWTPayload {
    userId: string;
    email: string;
    iat?: number;
    exp?: number;
  }
  
  export class JWTUtils {
    private static readonly SECRET = process.env.JWT_SECRET || 'your-secret-key';
    private static readonly EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';
  
    static generateToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
      return jwt.sign(payload, this.SECRET, { expiresIn: this.EXPIRES_IN });
    }
  
    static verifyToken(token: string): JWTPayload {
      return jwt.verify(token, this.SECRET) as JWTPayload;
    }
  
    static generateRefreshToken(userId: string): string {
      return jwt.sign({ userId }, this.SECRET, { expiresIn: '30d' });
    }
  }
  ```

- [ ] **认证中间件**
  ```typescript
  // src/middleware/auth.ts
  import { Request, Response, NextFunction } from 'express';
  import { JWTUtils } from '../utils/jwt';
  import { User } from '../models/User';
  
  export interface AuthRequest extends Request {
    user?: any;
  }
  
  export const authenticate = async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
      const token = req.header('Authorization')?.replace('Bearer ', '');
  
      if (!token) {
        return res.status(401).json({ success: false, message: '访问令牌缺失' });
      }
  
      const decoded = JWTUtils.verifyToken(token);
      const user = await User.findById(decoded.userId).select('-password');
  
      if (!user) {
        return res.status(401).json({ success: false, message: '用户不存在' });
      }
  
      req.user = user;
      next();
    } catch (error) {
      res.status(401).json({ success: false, message: '无效的访问令牌' });
    }
  };
  ```

#### 3.2 权限控制系统
- [ ] **权限检查中间件**
  ```typescript
  // src/middleware/permission.ts
  import { Response, NextFunction } from 'express';
  import { AuthRequest } from './auth';
  import { Profile } from '../models/Profile';
  
  export const checkProfilePermission = (requiredPermission: 'view' | 'edit' | 'delete' | 'share') => {
    return async (req: AuthRequest, res: Response, next: NextFunction) => {
      try {
        const profileId = req.params.profileId;
        const userId = req.user._id;
  
        const profile = await Profile.findById(profileId);
        if (!profile) {
          return res.status(404).json({ success: false, message: '档案不存在' });
        }
  
        // 检查用户是否有权限
        const permission = profile.permissions.find(p => p.userId.toString() === userId.toString());
        
        if (!permission) {
          return res.status(403).json({ success: false, message: '无权限访问此档案' });
        }
  
        // 检查具体权限
        const hasPermission = {
          view: permission.canView,
          edit: permission.canEdit,
          delete: permission.canDelete,
          share: permission.canShare
        }[requiredPermission];
  
        if (!hasPermission) {
          return res.status(403).json({ success: false, message: `无${requiredPermission}权限` });
        }
  
        req.profile = profile;
        req.permission = permission;
        next();
      } catch (error) {
        res.status(500).json({ success: false, message: '权限检查失败' });
      }
    };
  };
  ```

### 4. 核心业务API实现

#### 4.1 用户管理API
- [ ] **用户注册登录**
  ```typescript
  // src/controllers/AuthController.ts
  export class AuthController {
    // 用户注册
    static async register(req: Request, res: Response) {
      try {
        const { username, email, password } = req.body;
  
        // 验证输入
        const { error } = registerSchema.validate(req.body);
        if (error) {
          return res.status(400).json({ success: false, message: error.details[0].message });
        }
  
        // 检查用户是否已存在
        const existingUser = await User.findOne({ $or: [{ email }, { username }] });
        if (existingUser) {
          return res.status(400).json({ success: false, message: '用户已存在' });
        }
  
        // 创建用户
        const user = new User({ username, email, password });
        await user.save();
  
        // 创建默认档案
        const profile = new Profile({
          userId: user._id,
          name: username,
          type: 'self',
          permissions: [{
            userId: user._id,
            role: 'owner',
            canEdit: true,
            canView: true,
            canShare: true,
            canDelete: true,
            grantedBy: user._id
          }]
        });
        await profile.save();
  
        // 生成JWT令牌
        const token = JWTUtils.generateToken({ userId: user._id.toString(), email });
  
        res.status(201).json({
          success: true,
          message: '注册成功',
          data: {
            user: { id: user._id, username, email },
            profile: { id: profile._id, name: profile.name, type: profile.type },
            token
          }
        });
      } catch (error) {
        res.status(500).json({ success: false, message: '注册失败' });
      }
    }
  
    // 用户登录
    static async login(req: Request, res: Response) {
      try {
        const { email, password } = req.body;
  
        // 查找用户
        const user = await User.findOne({ email });
        if (!user || !(await user.comparePassword(password))) {
          return res.status(401).json({ success: false, message: '邮箱或密码错误' });
        }
  
        // 更新最后登录时间
        user.lastLoginAt = new Date();
        await user.save();
  
        // 生成JWT令牌
        const token = JWTUtils.generateToken({ userId: user._id.toString(), email });
  
        // 获取用户档案
        const profiles = await Profile.find({ 
          'permissions.userId': user._id,
          isActive: true 
        }).select('name type avatar permissions');
  
        res.json({
          success: true,
          message: '登录成功',
          data: {
            user: { id: user._id, username: user.username, email },
            profiles,
            token
          }
        });
      } catch (error) {
        res.status(500).json({ success: false, message: '登录失败' });
      }
    }
  }
  ```

#### 4.2 档案管理API
- [ ] **档案CRUD操作**
  ```typescript
  // src/controllers/ProfileController.ts
  export class ProfileController {
    // 获取档案列表
    static async getProfiles(req: AuthRequest, res: Response) {
      try {
        const userId = req.user._id;
        
        const profiles = await Profile.find({
          'permissions.userId': userId,
          isActive: true
        }).populate('userId', 'username email avatar');
  
        res.json({
          success: true,
          data: profiles
        });
      } catch (error) {
        res.status(500).json({ success: false, message: '获取档案列表失败' });
      }
    }
  
    // 创建新档案
    static async createProfile(req: AuthRequest, res: Response) {
      try {
        const { name, type, birthDate, gender, bio } = req.body;
        const userId = req.user._id;
  
        const profile = new Profile({
          userId,
          name,
          type,
          birthDate,
          gender,
          bio,
          permissions: [{
            userId,
            role: 'owner',
            canEdit: true,
            canView: true,
            canShare: true,
            canDelete: true,
            grantedBy: userId
          }]
        });
  
        await profile.save();
  
        res.status(201).json({
          success: true,
          message: '档案创建成功',
          data: profile
        });
      } catch (error) {
        res.status(500).json({ success: false, message: '档案创建失败' });
      }
    }
  
    // 设置档案权限
    static async setPermission(req: AuthRequest, res: Response) {
      try {
        const { profileId } = req.params;
        const { userId: targetUserId, role, permissions } = req.body;
        const currentUserId = req.user._id;
  
        const profile = await Profile.findById(profileId);
        if (!profile) {
          return res.status(404).json({ success: false, message: '档案不存在' });
        }
  
        // 检查当前用户是否为档案所有者
        const currentPermission = profile.permissions.find(p => 
          p.userId.toString() === currentUserId.toString() && p.role === 'owner'
        );
  
        if (!currentPermission) {
          return res.status(403).json({ success: false, message: '只有档案所有者可以设置权限' });
        }
  
        // 添加或更新权限
        const existingPermissionIndex = profile.permissions.findIndex(p => 
          p.userId.toString() === targetUserId
        );
  
        const newPermission = {
          userId: targetUserId,
          role,
          ...permissions,
          grantedAt: new Date(),
          grantedBy: currentUserId
        };
  
        if (existingPermissionIndex >= 0) {
          profile.permissions[existingPermissionIndex] = newPermission;
        } else {
          profile.permissions.push(newPermission);
        }
  
        await profile.save();
  
        res.json({
          success: true,
          message: '权限设置成功',
          data: profile
        });
      } catch (error) {
        res.status(500).json({ success: false, message: '权限设置失败' });
      }
    }
  }
  ```

#### 4.3 成就管理API
- [ ] **成就系统API**
  ```typescript
  // src/controllers/AchievementController.ts
  export class AchievementController {
    // 获取预设成就列表
    static async getAchievements(req: Request, res: Response) {
      try {
        const { category, ageGroup, page = 1, limit = 20 } = req.query;
        
        const filter: any = { isDefault: true, isActive: true };
        if (category) filter.category = category;
        if (ageGroup) filter.ageGroup = ageGroup;
  
        const achievements = await Achievement.find(filter)
          .sort({ difficulty: 1, createdAt: -1 })
          .limit(Number(limit) * Number(page))
          .skip((Number(page) - 1) * Number(limit));
  
        const total = await Achievement.countDocuments(filter);
  
        res.json({
          success: true,
          data: {
            achievements,
            pagination: {
              page: Number(page),
              limit: Number(limit),
              total,
              pages: Math.ceil(total / Number(limit))
            }
          }
        });
      } catch (error) {
        res.status(500).json({ success: false, message: '获取成就列表失败' });
      }
    }
  
    // 点亮成就
    static async unlockAchievement(req: AuthRequest, res: Response) {
      try {
        const { profileId } = req.params;
        const { achievementId, title, description, images, videos, audio, location, emotion, tags, isPublic, achievedAt } = req.body;
        const recordedBy = req.user._id;
  
        // 检查成就是否已存在
        const existingAchievement = await UserAchievement.findOne({ profileId, achievementId });
        if (existingAchievement) {
          return res.status(400).json({ success: false, message: '成就已点亮' });
        }
  
        const userAchievement = new UserAchievement({
          profileId,
          achievementId,
          title,
          description,
          images: images || [],
          videos: videos || [],
          audio,
          location,
          emotion,
          tags: tags || [],
          isPublic: isPublic !== false,
          recordedBy,
          recordedAt: new Date(),
          achievedAt: achievedAt ? new Date(achievedAt) : new Date()
        });
  
        await userAchievement.save();
  
        // 填充成就详情
        await userAchievement.populate('achievementId');
        await userAchievement.populate('recordedBy', 'username avatar');
  
        res.status(201).json({
          success: true,
          message: '成就点亮成功',
          data: userAchievement
        });
      } catch (error) {
        res.status(500).json({ success: false, message: '成就点亮失败' });
      }
    }
  
    // 获取档案成就
    static async getProfileAchievements(req: AuthRequest, res: Response) {
      try {
        const { profileId } = req.params;
        const { category, emotion, page = 1, limit = 20 } = req.query;
  
        const filter: any = { profileId };
        if (category) {
          // 通过关联的成就查询分类
          const achievements = await Achievement.find({ category }).select('_id');
          filter.achievementId = { $in: achievements.map(a => a._id) };
        }
        if (emotion) filter.emotion = emotion;
  
        const userAchievements = await UserAchievement.find(filter)
          .populate('achievementId')
          .populate('recordedBy', 'username avatar')
          .sort({ achievedAt: -1 })
          .limit(Number(limit) * Number(page))
          .skip((Number(page) - 1) * Number(limit));
  
        const total = await UserAchievement.countDocuments(filter);
  
        res.json({
          success: true,
          data: {
            achievements: userAchievements,
            pagination: {
              page: Number(page),
              limit: Number(limit),
              total,
              pages: Math.ceil(total / Number(limit))
            }
          }
        });
      } catch (error) {
        res.status(500).json({ success: false, message: '获取档案成就失败' });
      }
    }
  }
  ```

#### 4.4 地图打卡API
- [ ] **地图服务API**
  ```typescript
  // src/controllers/MapController.ts
  export class MapController {
    // 创建打卡记录
    static async createCheckin(req: AuthRequest, res: Response) {
      try {
        const { profileId } = req.params;
        const { type, name, code, coordinates, address, images, description, checkedAt } = req.body;
  
        // 检查是否已经打卡过
        const existingCheckin = await MapCheckin.findOne({
          profileId,
          name,
          type,
          coordinates: {
            $near: {
              $geometry: {
                type: 'Point',
                coordinates: [coordinates.longitude, coordinates.latitude]
              },
              $maxDistance: 1000 // 1公里内认为是同一地点
            }
          }
        });
  
        if (existingCheckin) {
          return res.status(400).json({ success: false, message: '该地点已打卡' });
        }
  
        const checkin = new MapCheckin({
          profileId,
          type,
          name,
          code,
          coordinates,
          address,
          images: images || [],
          description,
          checkedAt: checkedAt ? new Date(checkedAt) : new Date()
        });
  
        await checkin.save();
  
        res.status(201).json({
          success: true,
          message: '打卡成功',
          data: checkin
        });
      } catch (error) {
        res.status(500).json({ success: false, message: '打卡失败' });
      }
    }
  
    // 获取档案足迹
    static async getProfileFootprints(req: AuthRequest, res: Response) {
      try {
        const { profileId } = req.params;
        const { type, startDate, endDate } = req.query;
  
        const filter: any = { profileId };
        if (type) filter.type = type;
        if (startDate || endDate) {
          filter.checkedAt = {};
          if (startDate) filter.checkedAt.$gte = new Date(startDate as string);
          if (endDate) filter.checkedAt.$lte = new Date(endDate as string);
        }
  
        const checkins = await MapCheckin.find(filter)
          .sort({ checkedAt: -1 });
  
        // 统计数据
        const stats = {
          totalCheckins: checkins.length,
          countries: new Set(checkins.filter(c => c.type === 'country').map(c => c.name)).size,
          provinces: new Set(checkins.filter(c => c.type === 'province').map(c => c.name)).size,
          cities: new Set(checkins.filter(c => c.type === 'city').map(c => c.name)).size,
          landmarks: checkins.filter(c => c.type === 'landmark').length
        };
  
        res.json({
          success: true,
          data: {
            checkins,
            stats
          }
        });
      } catch (error) {
        res.status(500).json({ success: false, message: '获取足迹失败' });
      }
    }
  
    // 获取地图数据
    static async getMapData(req: AuthRequest, res: Response) {
      try {
        const { profileId } = req.params;
        const { mapType = 'world' } = req.query;
  
        const checkins = await MapCheckin.find({ profileId });
  
        let mapData;
        if (mapType === 'world') {
          // 世界地图数据
          mapData = {
            countries: checkins.filter(c => c.type === 'country'),
            stats: {
              visitedCountries: new Set(checkins.filter(c => c.type === 'country').map(c => c.name)).size,
              totalCountries: 195 // 世界总国家数
            }
          };
        } else if (mapType === 'china') {
          // 中国地图数据
          mapData = {
            provinces: checkins.filter(c => c.type === 'province'),
            cities: checkins.filter(c => c.type === 'city'),
            stats: {
              visitedProvinces: new Set(checkins.filter(c => c.type === 'province').map(c => c.name)).size,
              visitedCities: new Set(checkins.filter(c => c.type === 'city').map(c => c.name)).size,
              totalProvinces: 34 // 中国总省份数
            }
          };
        }
  
        res.json({
          success: true,
          data: mapData
        });
      } catch (error) {
        res.status(500).json({ success: false, message: '获取地图数据失败' });
      }
    }
  }
  ```

### 5. 第三方服务集成

#### 5.1 文件上传服务
- [ ] **阿里云OSS集成**
  ```typescript
  // src/services/FileService.ts
  import OSS from 'ali-oss';
  import multer from 'multer';
  import { v4 as uuidv4 } from 'uuid';
  
  export class FileService {
    private ossClient: OSS;
  
    constructor() {
      this.ossClient = new OSS({
        region: process.env.OSS_REGION,
        accessKeyId: process.env.OSS_ACCESS_KEY_ID!,
        accessKeySecret: process.env.OSS_ACCESS_KEY_SECRET!,
        bucket: process.env.OSS_BUCKET
      });
    }
  
    // 上传图片
    async uploadImage(file: Express.Multer.File, folder: string = 'images'): Promise<string> {
      const fileName = `${folder}/${uuidv4()}.${file.originalname.split('.').pop()}`;
      
      try {
        const result = await this.ossClient.put(fileName, file.buffer);
        return result.url;
      } catch (error) {
        throw new Error('图片上传失败');
      }
    }
  
    // 上传视频
    async uploadVideo(file: Express.Multer.File, folder: string = 'videos'): Promise<string> {
      const fileName = `${folder}/${uuidv4()}.${file.originalname.split('.').pop()}`;
      
      try {
        const result = await this.ossClient.put(fileName, file.buffer);
        return result.url;
      } catch (error) {
        throw new Error('视频上传失败');
      }
    }
  
    // 删除文件
    async deleteFile(url: string): Promise<void> {
      try {
        const fileName = url.split('/').pop();
        if (fileName) {
          await this.ossClient.delete(fileName);
        }
      } catch (error) {
        console.error('文件删除失败:', error);
      }
    }
  }
  
  // Multer配置
  export const upload = multer({
    storage: multer.memoryStorage(),
    limits: {
      fileSize: 10 * 1024 * 1024, // 10MB
    },
    fileFilter: (req, file, cb) => {
      if (file.fieldname === 'image') {
        if (file.mimetype.startsWith('image/')) {
          cb(null, true);
        } else {
          cb(new Error('只允许上传图片文件'));
        }
      } else if (file.fieldname === 'video') {
        if (file.mimetype.startsWith('video/')) {
          cb(null, true);
        } else {
          cb(new Error('只允许上传视频文件'));
        }
      } else {
        cb(new Error('不支持的文件类型'));
      }
    }
  });
  ```

#### 5.2 推送服务集成
- [ ] **极光推送集成**
  ```typescript
  // src/services/PushService.ts
  import JPush from 'jpush-sdk';
  
  export class PushService {
    private client: JPush;
  
    constructor() {
      this.client = JPush.buildClient({
        appKey: process.env.JPUSH_APP_KEY!,
        masterSecret: process.env.JPUSH_MASTER_SECRET!
      });
    }
  
    // 发送成就提醒
    async sendAchievementReminder(userId: string, achievement: any): Promise<void> {
      try {
        await this.client.push()
          .setPlatform('all')
          .setAudience(JPush.alias(userId))
          .setNotification({
            alert: `新成就推荐：${achievement.title}`,
            android: {
              title: '初见 - 成就推荐',
              alert: `快来点亮「${achievement.title}」成就吧！`
            },
            ios: {
              alert: `快来点亮「${achievement.title}」成就吧！`,
              badge: 1,
              sound: 'default'
            }
          })
          .setMessage({
            msg_content: JSON.stringify({
              type: 'achievement_reminder',
              achievementId: achievement._id
            })
          })
          .send();
      } catch (error) {
        console.error('推送发送失败:', error);
      }
    }
  
    // 发送地点打卡提醒
    async sendLocationReminder(userId: string, location: any): Promise<void> {
      try {
        await this.client.push()
          .setPlatform('all')
          .setAudience(JPush.alias(userId))
          .setNotification({
            alert: `发现新地点：${location.name}`,
            android: {
              title: '初见 - 地点发现',
              alert: `您来到了${location.name}，快来打卡吧！`
            },
            ios: {
              alert: `您来到了${location.name}，快来打卡吧！`,
              badge: 1,
              sound: 'default'
            }
          })
          .setMessage({
            msg_content: JSON.stringify({
              type: 'location_reminder',
              location
            })
          })
          .send();
      } catch (error) {
        console.error('推送发送失败:', error);
      }
    }
  }
  ```

### 6. 数据统计与分析

#### 6.1 统计服务
- [ ] **成就统计API**
  ```typescript
  // src/controllers/StatsController.ts
  export class StatsController {
    // 获取档案统计数据
    static async getProfileStats(req: AuthRequest, res: Response) {
      try {
        const { profileId } = req.params;
  
        // 成就统计
        const achievementStats = await UserAchievement.aggregate([
          { $match: { profileId: new mongoose.Types.ObjectId(profileId) } },
          {
            $lookup: {
              from: 'achievements',
              localField: 'achievementId',
              foreignField: '_id',
              as: 'achievement'
            }
          },
          { $unwind: '$achievement' },
          {
            $group: {
              _id: '$achievement.category',
              count: { $sum: 1 },
              totalDifficulty: { $sum: '$achievement.difficulty' }
            }
          }
        ]);
  
        // 地图统计
        const mapStats = await MapCheckin.aggregate([
          { $match: { profileId: new mongoose.Types.ObjectId(profileId) } },
          {
            $group: {
              _id: '$type',
              count: { $sum: 1 },
              locations: { $addToSet: '$name' }
            }
          }
        ]);
  
        // 时间统计
        const timeStats = await UserAchievement.aggregate([
          { $match: { profileId: new mongoose.Types.ObjectId(profileId) } },
          {
            $group: {
              _id: {
                year: { $year: '$achievedAt' },
                month: { $month: '$achievedAt' }
              },
              count: { $sum: 1 }
            }
          },
          { $sort: { '_id.year': 1, '_id.month': 1 } }
        ]);
  
        res.json({
          success: true,
          data: {
            achievements: achievementStats,
            map: mapStats,
            timeline: timeStats
          }
        });
      } catch (error) {
        res.status(500).json({ success: false, message: '获取统计数据失败' });
      }
    }
  }
  ```

### 7. API文档和测试

#### 7.1 Swagger API文档
- [ ] **Swagger配置**
  ```typescript
  // src/config/swagger.ts
  import swaggerJSDoc from 'swagger-jsdoc';
  import swaggerUi from 'swagger-ui-express';
  
  const options = {
    definition: {
      openapi: '3.0.0',
      info: {
        title: '初见APP API文档',
        version: '1.0.0',
        description: '记录人生第一次的时光记录APP API接口文档'
      },
      servers: [
        {
          url: process.env.API_BASE_URL || 'http://localhost:3000',
          description: '开发环境'
        }
      ],
      components: {
        securitySchemes: {
          bearerAuth: {
            type: 'http',
            scheme: 'bearer',
            bearerFormat: 'JWT'
          }
        }
      }
    },
    apis: ['./src/routes/*.ts', './src/controllers/*.ts']
  };
  
  const specs = swaggerJSDoc(options);
  
  export { swaggerUi, specs };
  ```

#### 7.2 单元测试
- [ ] **Jest测试配置**
  ```typescript
  // tests/auth.test.ts
  import request from 'supertest';
  import app from '../src/app';
  import { User } from '../src/models/User';
  
  describe('Auth API', () => {
    beforeEach(async () => {
      await User.deleteMany({});
    });
  
    describe('POST /api/v1/auth/register', () => {
      it('should register a new user', async () => {
        const userData = {
          username: 'testuser',
          email: 'test@example.com',
          password: 'password123'
        };
  
        const response = await request(app)
          .post('/api/v1/auth/register')
          .send(userData)
          .expect(201);
  
        expect(response.body.success).toBe(true);
        expect(response.body.data.user.email).toBe(userData.email);
        expect(response.body.data.token).toBeDefined();
      });
  
      it('should not register user with existing email', async () => {
        const userData = {
          username: 'testuser',
          email: 'test@example.com',
          password: 'password123'
        };
  
        // 第一次注册
        await request(app)
          .post('/api/v1/auth/register')
          .send(userData);
  
        // 第二次注册相同邮箱
        const response = await request(app)
          .post('/api/v1/auth/register')
          .send(userData)
          .expect(400);
  
        expect(response.body.success).toBe(false);
        expect(response.body.message).toContain('用户已存在');
      });
    });
  });
  ```

## 部署与运维

### 1. Docker容器化
- [ ] **Dockerfile配置**
  ```dockerfile
  # Dockerfile
  FROM node:18-alpine
  
  WORKDIR /app
  
  # 复制package文件
  COPY package*.json ./
  
  # 安装依赖
  RUN npm ci --only=production
  
  # 复制源代码
  COPY . .
  
  # 构建TypeScript
  RUN npm run build
  
  # 暴露端口
  EXPOSE 3000
  
  # 启动应用
  CMD ["npm", "start"]
  ```

- [ ] **docker-compose配置**
  ```yaml
  # docker-compose.yml
  version: '3.8'
  
  services:
    app:
      build: .
      ports:
        - "3000:3000"
      environment:
        - NODE_ENV=production
        - MONGODB_URI=mongodb://mongo:27017/first-moments
        - REDIS_HOST=redis
      depends_on:
        - mongo
        - redis
  
    mongo:
      image: mongo:5.0
      ports:
        - "27017:27017"
      volumes:
        - mongo_data:/data/db
  
    redis:
      image: redis:7-alpine
      ports:
        - "6379:6379"
      volumes:
        - redis_data:/data
  
  volumes:
    mongo_data:
    redis_data:
  ```

### 2. 监控和日志
- [ ] **健康检查端点**
  ```typescript
  // src/routes/health.ts
  import { Router } from 'express';
  import mongoose from 'mongoose';
  import { redisClient } from '../config/redis';
  
  const router = Router();
  
  router.get('/health', async (req, res) => {
    const health = {
      status: 'ok',
      timestamp: new Date().toISOString(),
      services: {
        database: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
        redis: redisClient.isReady ? 'connected' : 'disconnected'
      }
    };
  
    const statusCode = health.services.database === 'connected' && health.services.redis === 'connected' ? 200 : 503;
    res.status(statusCode).json(health);
  });
  
  export default router;
  ```

## 交付成果

### 1. 代码交付
- [ ] 完整的后端服务代码
- [ ] API接口实现
- [ ] 数据库模型和迁移脚本
- [ ] 单元测试和集成测试
- [ ] Docker部署配置

### 2. 文档交付
- [ ] API接口文档 (Swagger)
- [ ] 数据库设计文档
- [ ] 部署运维文档
- [ ] 开发者指南

### 3. 环境交付
- [ ] 开发环境部署
- [ ] 测试环境部署
- [ ] 生产环境准备
- [ ] 监控告警配置

## 质量保证

### 1. 代码质量
- [ ] TypeScript类型检查
- [ ] ESLint代码规范检查
- [ ] 单元测试覆盖率 >80%
- [ ] 集成测试覆盖核心功能

### 2. 性能要求
- [ ] API响应时间 <500ms
- [ ] 数据库查询优化
- [ ] 缓存命中率 >90%
- [ ] 并发处理能力 >1000 QPS

### 3. 安全要求
- [ ] 输入验证和过滤
- [ ] SQL注入防护
- [ ] XSS攻击防护
- [ ] 敏感数据加密

## 风险控制

### 技术风险
- **第三方服务依赖**：准备备选方案和降级策略
- **数据库性能**：提前进行性能测试和优化
- **并发处理**：使用负载测试验证系统承载能力

### 进度风险
- **需求变更**：建立变更管理流程
- **技术难点**：提前进行技术预研
- **测试延期**：并行开发和测试

---

**阶段负责人**：后端技术负责人 + 后端开发工程师  
**评审节点**：第4月末进行后端评审  
**验收标准**：所有API接口完成，单元测试通过，部署环境可用